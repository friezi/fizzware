################################################################################
########################### FOR EDITING ########################################

TARGET = <hier den gewünschten Programmnamen eingeben>

MAIN_MODULE = <Name des Hauptmoduls>
LOCAL_MODULES = <Lokale (im gleichen Verzeichnis wie <MAIN_MODULE>) Module>
EXTERN_MODULES = <Klassenmodule im Verzeichnis <EM_PATH>>

CLASSLIBRARY_PATH = < alternativ o. zusaetzlich Pfad fuer lokale Klassenbibliothek (statisch) >
CLASSLIBRARY = < Name der Klassenbibliothek (ohne lib und .a) >
CLASS_MODULES = < Module der Bibliothek, bei deren Aenderung auch das TARGET-file neu compiliert werden muss >

EM_PATH = $(CLASSLIBRARY_PATH) <Pfad der für die Module <EXTERN_MODULES>>

IMPORTANT_HEADERS = <wichtige Header-files angeben (ohne .hpp), die nicht automatisch geladen werden, z.B. fuer Templates>

LIBRARY_INCLUDE_PATHS = <alle Pfade fuer Library-Includes angeben>
LIBRARIES = <zu linkende Bibliotheksnamen angeben (einfacher Name!)>
LIBRARY_PATHS = <Pfade fuer Bibliotheken>

EDITOR ?= vi

DIST_DIR = ../dist
DT_DIR = $(DIST_DIR)/$(TARGET)

### check the field CC ########################################################
################################################################################
################################################################################

MM_OBJECT = $(MAIN_MODULE:=.o)
MM_SOURCE = $(MAIN_MODULE:=.cpp)
MM_HEADER = $(MAIN_MODULE:=.hpp)
LM_SOURCES = $(LOCAL_MODULES:=.cpp)
LM_HEADERS = $(LOCAL_MODULES:=.hpp)
LM_OBJECTS = $(LOCAL_MODULES:=.o)
EM_SOURCES = $(EXTERN_MODULES:%=$(EM_PATH)/%.cpp)
EM_HEADERS = $(EXTERN_MODULES:%=$(EM_PATH)/%.hpp)
EM_OBJECTS = $(EXTERN_MODULES:%=$(EM_PATH)/%.o)
CM_HEADERS = $(CLASS_MODULES:%=$(EM_PATH)/%.hpp)
CM_MAKEFILES = $(CLASS_MODULES:%=-f $(CLASSLIBRARY_PATH)/%/Makefile)
IM_HEADERS = $(IMPORTANT_HEADERS:=.hpp)
LI_PATHS = $(LIBRARY_INCLUDE_PATHS:%=-I %)
LIBS = $(LIBRARIES:%=-l%)
L_PATHS = $(LIBRARY_PATHS:%=-L %)
CL_LIB = $(CLASSLIBRARY:%=-l%)
CL_PATH = $(CLASSLIBRARY_PATH:%=-L %)
LIB_NAME = $(CLASSLIBRARY:%=$(CLASSLIBRARY_PATH)/lib%.a)
MAKE_CL_LIB = $(CLASSLIBRARY_PATH:%=$(MAKE) -k -C $(CLASSLIBRARY_PATH) -f %/Makefile)

#bei systemspezifischer Programmierung "-ansi" ausschalten
CC = g++ -Wall -Wconversion -ansi -pedantic -O3 -I $(EM_PATH) $(LI_PATHS) $(L_PATHS) $(CL_PATH)

.PHONY: all clean $(LIB_NAME)_all dist

# falls von lokaler Bibliothek abhaengig, soll diese erst generiert werden
all: $(LIB_NAME)_all $(TARGET)

# <TARGET> compilieren
$(TARGET): $(MM_OBJECT) $(LM_OBJECTS) $(EM_OBJECTS) $(LIB_NAME)
	$(CC) $(MM_OBJECT) $(LM_OBJECTS) $(EM_OBJECTS) -o $(TARGET) $(LIBS) $(CL_LIB)
	strip $(TARGET)

# Zeilen zählen, falls gewünscht
#	wc -l $(MM_SOURCE) $(MM_HEADER) $(LM_SOURCES) $(LM_HEADERS) $(EM_SOURCES) $(EM_HEADERS)

# compilieren der Module 
%.o: %.cpp %.hpp
	$(CC) $< -c -o $@

# <MAIN_MODULE> hängt von allen Header-files ab
$(MM_OBJECT): $(MM_HEADER) $(LM_HEADERS) $(EM_HEADERS) $(CM_HEADERS) $(IM_HEADERS)

# es können zusäzliche spezielle Abhängigkeiten definiert werden


# Generierung der lokalen Bibliothek (ist so eingestellt, dass sie nur bei Aenderungen generiert wird
$(LIB_NAME)_all:
	$(MAKE_CL_LIB)

$(LIB_NAME):
# hier braucht nichts zu passieren, da die Library sowieso im Feld $(TARGET) generiert wird

# alle Module löschen
clean:
	rm -f $(TARGET) *.o $(EM_OBJECTS)

# Editor aufrufen
ed:
	$(EDITOR) Makefile $(MAIN_MODULE:=.?pp) $(LOCAL_MODULES:=.?pp) $(EXTERN_MODULES:%=$(EM_PATH)/%.?pp) $(CLASS_MODULES:%=$(CLASSLIBRARY_PATH)/%.?pp) $(IM_HEADERS) &

# erstelle Packet fuer Distribution
dist:
	cd ../classes; make -k dist; cd -;
	[[ -d $(DIST_DIR) ]] || mkdir $(DIST_DIR)
	[[ -d $(DT_DIR) ]] || mkdir $(DT_DIR)
	cp --target-directory=$(DT_DIR) $(MAIN_MODULE:=.?pp) $(LOCAL_MODULES:=.?pp) $(EXTERN_MODULES:%=$(EM_PATH)/%.?pp) Makefile
